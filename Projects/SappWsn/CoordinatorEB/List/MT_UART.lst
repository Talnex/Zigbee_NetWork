###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               14/Jul/2019  17:09:46
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Components\mt\MT_UART.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWF95C.tmp
#        ("C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Components\mt\MT_UART.c" -D ZTOOL_P1 -D
#        MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D SAPP_ZSTACK -lC
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\CoordinatorEB\List" -lA
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\CoordinatorEB\Obj" -e --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 8 -f "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4545
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\" -I
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\Source\" -I
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\" -I
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\" -I
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\"
#        -I "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\" -I
#        "C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\CoordinatorEB\List\MT_UART.lst
#    Object file        =  
#        C:\Users\Administrator\Desktop\111 -
#        副本\ZStack-CC2530-r200\Projects\SappWsn\CoordinatorEB\Obj\MT_UART.r51
#
###############################################################################

C:\Users\Administrator\Desktop\111 - 副本\ZStack-CC2530-r200\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define LEN_STATE      0x01
     61          #define DATA_STATE     0x02
     62          #define FCS_STATE      0x03
     63          
     64          /***************************************************************************************************
     65           *                                         GLOBAL VARIABLES
     66           ***************************************************************************************************/
     67          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     68          uint8 App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     69          
     70          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          uint8 state = SOP_STATE;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          mtUserSerialMsg_t   *pMsgContent;
   \                     pMsgContent:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     75          
     76          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     77          uint16  MT_UartMaxZAppBufLen;
     78          bool    MT_UartZAppRxStatus;
     79          #endif
     80          
     81          
     82          /***************************************************************************************************
     83           *                                          LOCAL FUNCTIONS
     84           ***************************************************************************************************/
     85          
     86          /***************************************************************************************************
     87           * @fn      MT_UartInit
     88           *
     89           * @brief   Initialize MT with UART support
     90           *
     91           * @param   None
     92           *
     93           * @return  None
     94          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     95          void MT_UartInit ()
   \                     MT_UartInit:
     96          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV       A,#-0x1d
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
     97            halUARTCfg_t uartConfig;
     98          
     99            /* Initialize APP ID */
    100            App_TaskID = 0;
   \   000009   90....       MOV       DPTR,#App_TaskID
   \   00000C   E4           CLR       A
   \   00000D   F0           MOVX      @DPTR,A
    101          
    102            /* UART Configuration */
    103            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    104            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   7404         MOV       A,#0x4
   \   00001B   F0           MOVX      @DPTR,A
    105            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
    106            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000023   7403         MOV       A,#0x3
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   7440         MOV       A,#0x40
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
    107            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002E   740A         MOV       A,#0xa
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   7480         MOV       A,#-0x80
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
    108            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000039   7412         MOV       A,#0x12
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   7480         MOV       A,#-0x80
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   E4           CLR       A
   \   000043   F0           MOVX      @DPTR,A
    109            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000044   7405         MOV       A,#0x5
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   7406         MOV       A,#0x6
   \   00004B   F0           MOVX      @DPTR,A
    110            uartConfig.intEnable            = TRUE;
   \   00004C   7416         MOV       A,#0x16
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   7401         MOV       A,#0x1
   \   000053   F0           MOVX      @DPTR,A
    111          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    112            uartConfig.callBackFunc         = MT_UartProcessZToolData1;
   \   000054   741B         MOV       A,#0x1b
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   74..         MOV       A,#`??MT_UartProcessZToolData1::?relay` & 0xff
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   74..         MOV       A,#(`??MT_UartProcessZToolData1::?relay` >> 8) & 0xff
   \   00005F   F0           MOVX      @DPTR,A
    113          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    114            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    115          #else
    116            uartConfig.callBackFunc         = NULL;
    117          #endif
    118          
    119            /* Start UART */
    120          #if defined (MT_UART_DEFAULT_PORT)
    121            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   000060                ; Setup parameters for call to function HalUARTOpen
   \   000060   AA..         MOV       R2,?XSP + 0
   \   000062   AB..         MOV       R3,?XSP + 1
   \   000064   7900         MOV       R1,#0x0
   \   000066   12....       LCALL     `??HalUARTOpen::?relay`; Banked call to: HalUARTOpen
    122          #else
    123            /* Silence IAR compiler warning */
    124            (void)uartConfig;
    125          #endif
    126          
    127            /* Initialize for ZApp */
    128          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    129            /* Default max bytes that ZAPP can take */
    130            MT_UartMaxZAppBufLen  = 1;
    131            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    132          #endif
    133          
    134          }
   \   000069   741D         MOV       A,#0x1d
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006E                REQUIRE ?Subroutine0
   \   00006E                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    135          
    136          /***************************************************************************************************
    137           * @fn      MT_SerialRegisterTaskID
    138           *
    139           * @brief   This function registers the taskID of the application so it knows
    140           *          where to send the messages whent they come in.
    141           *
    142           * @param   void
    143           *
    144           * @return  void
    145           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    146          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    147          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    148            App_TaskID = taskID;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   F0           MOVX      @DPTR,A
    149          }
   \   000009   80..         SJMP      ?Subroutine0
    150          
    151          /***************************************************************************************************
    152           * @fn      SPIMgr_CalcFCS
    153           *
    154           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    155           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    156           *
    157           * @param   byte *msg_ptr - message pointer
    158           * @param   byte len - length (in bytes) of message
    159           *
    160           * @return  result byte
    161           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    162          byte MT_UartCalcFCS(uint8 lastResult, uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    163          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    164            uint8 x;
    165            uint8 xorResult = lastResult;
    166          
    167            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000005   7800         MOV       R0,#0x0
   \   000007   800E         SJMP      ??MT_UartCalcFCS_0
    168              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   C9           XCH       A,R1
   \   00000F   69           XRL       A,R1
   \   000010   F9           MOV       R1,A
   \   000011   08           INC       R0
   \   000012   A3           INC       DPTR
   \   000013   AA82         MOV       R2,DPL
   \   000015   AB83         MOV       R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   000017   E8           MOV       A,R0
   \   000018   C3           CLR       C
   \   000019   9C           SUBB      A,R4
   \   00001A   40ED         JC        ??MT_UartCalcFCS_1
    169          
    170            return ( xorResult );
   \   00001C   7F01         MOV       R7,#0x1
   \   00001E   02....       LJMP      ?BANKED_LEAVE_XDATA
    171          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    172          void MT_UartProcessZToolData1 ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData1:
    173          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 128
   \   000005   7480         MOV       A,#-0x80
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    174            uint8 flag = 0,i,j = 0;  //flag判断有没有数据，j记录数据长度
   \   00000C   75..00       MOV       ?V0,#0x0
   \   00000F   7F00         MOV       R7,#0x0
    175            uint8 buf[128];         //缓冲128
    176            (void)event;
   \   000011   801D         SJMP      ??MT_UartProcessZToolData1_0
    177          
    178            while(Hal_UART_RxBufLen(port)) //检测串口数据是否完成
    179            {
    180              HalUARTRead(port,&buf[j],1);//数据接收到buf
   \                     ??MT_UartProcessZToolData1_1:
   \   000013                ; Setup parameters for call to function HalUARTRead
   \   000013   7C01         MOV       R4,#0x1
   \   000015   7D00         MOV       R5,#0x0
   \   000017   EF           MOV       A,R7
   \   000018   F8           MOV       R0,A
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   E582         MOV       A,DPL
   \   000021   28           ADD       A,R0
   \   000022   FA           MOV       R2,A
   \   000023   E4           CLR       A
   \   000024   3583         ADDC      A,DPH
   \   000026   FB           MOV       R3,A
   \   000027   EE           MOV       A,R6
   \   000028   F9           MOV       R1,A
   \   000029   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
    181              j++;
   \   00002C   0F           INC       R7
    182              flag = 1;
   \   00002D   75..01       MOV       ?V0,#0x1
    183            }
   \                     ??MT_UartProcessZToolData1_0:
   \   000030                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000030   EE           MOV       A,R6
   \   000031   F9           MOV       R1,A
   \   000032   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   000035   EA           MOV       A,R2
   \   000036   4B           ORL       A,R3
   \   000037   70DA         JNZ       ??MT_UartProcessZToolData1_1
    184            if(flag == 1)   //有数据时
   \   000039   E5..         MOV       A,?V0
   \   00003B   6056         JZ        ??CrossCallReturnLabel_10
    185            {//分配内存，结构体+内容+长度
    186              pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof
    187                                                             ( mtOSALSerialData_t )+j+1);
   \   00003D                ; Setup parameters for call to function osal_msg_allocate
   \   00003D   EF           MOV       A,R7
   \   00003E   2405         ADD       A,#0x5
   \   000040   12....       LCALL     ?Subroutine4 & 0xFFFF
    188              pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??CrossCallReturnLabel_6:
   \   000043   12....       LCALL     ?Subroutine1 & 0xFFFF
    189              pMsg->msg = (uint8*)(pMsg+1); //把数据定位到结构体
    190              pMsg->msg [0]= j;             //记录数据长度
   \                     ??CrossCallReturnLabel_0:
   \   000046   EF           MOV       A,R7
   \   000047   8882         MOV       DPL,R0
   \   000049   8983         MOV       DPH,R1
   \   00004B   F0           MOVX      @DPTR,A
    191              for(i=0;i<j;i++)
   \   00004C   7A00         MOV       R2,#0x0
   \   00004E   8032         SJMP      ??MT_UartProcessZToolData1_2
    192                pMsg->msg [i+1]= buf[i];
   \                     ??MT_UartProcessZToolData1_3:
   \   000050   EA           MOV       A,R2
   \   000051   F8           MOV       R0,A
   \   000052   85..82       MOV       DPL,?XSP + 0
   \   000055   85..83       MOV       DPH,?XSP + 1
   \   000058   E582         MOV       A,DPL
   \   00005A   28           ADD       A,R0
   \   00005B   F582         MOV       DPL,A
   \   00005D   E4           CLR       A
   \   00005E   3583         ADDC      A,DPH
   \   000060   F583         MOV       DPH,A
   \   000062   E0           MOVX      A,@DPTR
   \   000063   C0E0         PUSH      A
   \   000065   90....       MOV       DPTR,#pMsg
   \   000068   E0           MOVX      A,@DPTR
   \   000069   FB           MOV       R3,A
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F583         MOV       DPH,A
   \   00006E   8B82         MOV       DPL,R3
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   E0           MOVX      A,@DPTR
   \   000073   28           ADD       A,R0
   \   000074   FB           MOV       R3,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   3400         ADDC      A,#0x0
   \   000079   8B82         MOV       DPL,R3
   \   00007B   F583         MOV       DPH,A
   \   00007D   A3           INC       DPTR
   \   00007E   D0E0         POP       A
   \   000080   F0           MOVX      @DPTR,A
   \   000081   0A           INC       R2
   \                     ??MT_UartProcessZToolData1_2:
   \   000082   EA           MOV       A,R2
   \   000083   C3           CLR       C
   \   000084   9F           SUBB      A,R7
   \   000085   40C9         JC        ??MT_UartProcessZToolData1_3
    193              osal_msg_send( App_TaskID, (byte *)pMsg ); // 登记任务并发往上层
   \   000087                ; Setup parameters for call to function osal_msg_send
   \   000087   90....       MOV       DPTR,#pMsg
   \   00008A   12....       LCALL     ?Subroutine3 & 0xFFFF
    194              osal_msg_deallocate ( (uint8 *)pMsg ); // 释放内存
   \                     ??CrossCallReturnLabel_4:
   \   00008D                ; Setup parameters for call to function osal_msg_deallocate
   \   00008D   90....       MOV       DPTR,#pMsg
   \   000090   12....       LCALL     ?Subroutine6 & 0xFFFF
    195            }
    196          }
   \                     ??CrossCallReturnLabel_10:
   \   000093   7480         MOV       A,#-0x80
   \   000095   12....       LCALL     ?DEALLOC_XSTACK8
   \   000098   7F04         MOV       R7,#0x4
   \   00009A   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   FA           MOV       R2,A
   \   000001   E4           CLR       A
   \   000002   3400         ADDC      A,#0x0
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000008   90....       MOV       DPTR,#pMsg
   \   00000B   EA           MOV       A,R2
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   A3           INC       DPTR
   \   00000E   EB           MOV       A,R3
   \   00000F   F0           MOVX      @DPTR,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   E0           MOVX      A,@DPTR
   \   000009   F9           MOV       R1,A
   \   00000A   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F583         MOV       DPH,A
   \   000002   8A82         MOV       DPL,R2
   \   000004   7401         MOV       A,#0x1
   \   000006   F0           MOVX      @DPTR,A
   \   000007   90....       MOV       DPTR,#pMsg
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   2404         ADD       A,#0x4
   \   00000D   F8           MOV       R0,A
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   3400         ADDC      A,#0x0
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#pMsg
   \   000016   E0           MOVX      A,@DPTR
   \   000017   FA           MOV       R2,A
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F583         MOV       DPH,A
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E8           MOV       A,R0
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   E9           MOV       A,R1
   \   000024   F0           MOVX      @DPTR,A
   \   000025   22           RET
    197          
    198          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    199          /***************************************************************************************************
    200           * @fn      MT_UartProcessZToolData
    201           *
    202           * @brief   | SOP | CMD |Data Length| cmdEP | Address | EndPoint |  Data  | FSC |
    203           *          |  1  |  2  |    1      |   2   |    2    |     1    | 1 ~119 |  1  |
    204           *
    205           *          Parses the data and determine either is SPI or just simply serial data
    206           *          then send the data to correct place (MT or APP)
    207           *
    208           * @param   port     - UART port
    209           *          event    - Event that causes the callback
    210           *
    211           *
    212           * @return  None
    213           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    215          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    216              uint8  ch;
    217              uint8  bytesInRxBuffer;
    218          
    219              (void)event;  // Intentionally unreferenced parameter
   \   00000C   802B         SJMP      ??MT_UartProcessZToolData_0
    220          
    221              while (Hal_UART_RxBufLen(port))
    222              {
    223                  HalUARTRead (port, &ch, 1);
    224          
    225                  switch(state)
    226                  {
    227                  case SOP_STATE:
    228                      if(ch == MT_UART_SOF)
    229                          state = LEN_STATE;
    230                      break;
    231                  case LEN_STATE:
    232                      if(ch < 7)
    233                      {
    234                          // invalid length field
    235                          state = SOP_STATE;
    236                          break;
    237                      }
    238                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) +
    239                                                                     ch + 3);//SOP+LEN+FSC
    240                      tempDataLen = 0;
    241                      /* Allocate memory for the data */
    242          //            pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) + sizeof(mtUserSerialMsg_t) +
    243          //                                                           ch - 5);
    244                      if (pMsg)
    245                      {
    246                          /* Fill up what we can */
    247                          pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   12....       LCALL     ?Subroutine1 & 0xFFFF
    248                          pMsg->msg = (uint8*)(pMsg + 1);
    249                          pMsgContent = (mtUserSerialMsg_t *)pMsg->msg;
   \                     ??CrossCallReturnLabel_1:
   \   000012   90....       MOV       DPTR,#pMsgContent
   \   000015   E8           MOV       A,R0
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   E9           MOV       A,R1
   \   000019   F0           MOVX      @DPTR,A
    250                          pMsgContent->sop = MT_UART_SOF;
   \   00001A   F583         MOV       DPH,A
   \   00001C   8882         MOV       DPL,R0
   \   00001E   A3           INC       DPTR
   \   00001F   7402         MOV       A,#0x2
   \   000021   F0           MOVX      @DPTR,A
    251                          pMsgContent->len = ch;
   \   000022   85..82       MOV       DPL,?XSP + 0
   \   000025   85..83       MOV       DPH,?XSP + 1
   \   000028   E0           MOVX      A,@DPTR
   \   000029   C0E0         PUSH      A
   \   00002B   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   D0E0         POP       A
   \   000032   F0           MOVX      @DPTR,A
    252                          state = DATA_STATE;
   \   000033   90....       MOV       DPTR,#state
   \   000036   7402         MOV       A,#0x2
   \                     ??MT_UartProcessZToolData_2:
   \   000038   F0           MOVX      @DPTR,A
    253                      }
    254                      else
    255                      {
    256                          pMsgContent = NULL;
    257                          state = SOP_STATE;
    258                          return;
    259                      }
    260                      break;
   \                     ??MT_UartProcessZToolData_0:
   \   000039                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000039   EE           MOV       A,R6
   \   00003A   F9           MOV       R1,A
   \   00003B   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   00003E   EA           MOV       A,R2
   \   00003F   4B           ORL       A,R3
   \   000040   7003         JNZ       $+5
   \   000042   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
   \   000045                ; Setup parameters for call to function HalUARTRead
   \   000045   7C01         MOV       R4,#0x1
   \   000047   7D00         MOV       R5,#0x0
   \   000049   AA..         MOV       R2,?XSP + 0
   \   00004B   AB..         MOV       R3,?XSP + 1
   \   00004D   EE           MOV       A,R6
   \   00004E   F9           MOV       R1,A
   \   00004F   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000052   90....       MOV       DPTR,#state
   \   000055   E0           MOVX      A,@DPTR
   \   000056   600E         JZ        ??MT_UartProcessZToolData_4
   \   000058   14           DEC       A
   \   000059   601D         JZ        ??MT_UartProcessZToolData_5
   \   00005B   14           DEC       A
   \   00005C   604E         JZ        ??MT_UartProcessZToolData_6
   \   00005E   14           DEC       A
   \   00005F   7003         JNZ       $+5
   \   000061   02....       LJMP      ??MT_UartProcessZToolData_7 & 0xFFFF
   \   000064   80D3         SJMP      ??MT_UartProcessZToolData_0
   \                     ??MT_UartProcessZToolData_4:
   \   000066   85..82       MOV       DPL,?XSP + 0
   \   000069   85..83       MOV       DPH,?XSP + 1
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   6402         XRL       A,#0x2
   \   00006F   70C8         JNZ       ??MT_UartProcessZToolData_0
   \   000071   90....       MOV       DPTR,#state
   \   000074   7401         MOV       A,#0x1
   \   000076   80C0         SJMP      ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_5:
   \   000078   85..82       MOV       DPL,?XSP + 0
   \   00007B   85..83       MOV       DPH,?XSP + 1
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   C3           CLR       C
   \   000080   9407         SUBB      A,#0x7
   \   000082   5003         JNC       $+5
   \   000084   02....       LJMP      ??CrossCallReturnLabel_11 & 0xFFFF
   \   000087                ; Setup parameters for call to function osal_msg_allocate
   \   000087   E0           MOVX      A,@DPTR
   \   000088   2407         ADD       A,#0x7
   \   00008A   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00008D   90....       MOV       DPTR,#tempDataLen
   \   000090   E4           CLR       A
   \   000091   F0           MOVX      @DPTR,A
   \   000092   90....       MOV       DPTR,#pMsg + 1
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F9           MOV       R1,A
   \   000097   EA           MOV       A,R2
   \   000098   49           ORL       A,R1
   \   000099   6003         JZ        $+5
   \   00009B   02....       LJMP      ??MT_UartProcessZToolData_1 & 0xFFFF
   \   00009E   90....       MOV       DPTR,#pMsgContent
   \   0000A1   E4           CLR       A
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   F0           MOVX      @DPTR,A
   \   0000A5   90....       MOV       DPTR,#state
   \   0000A8   F0           MOVX      @DPTR,A
   \   0000A9   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
    261                  case DATA_STATE:
    262                      pMsgContent->dataBody[tempDataLen++] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000AC   85..82       MOV       DPL,?XSP + 0
   \   0000AF   85..83       MOV       DPH,?XSP + 1
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   C0E0         PUSH      A
   \   0000B5   90....       MOV       DPTR,#tempDataLen
   \   0000B8   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000BB   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000BE   D0E0         POP       A
   \   0000C0   F0           MOVX      @DPTR,A
   \   0000C1   90....       MOV       DPTR,#tempDataLen
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   04           INC       A
   \   0000C6   F0           MOVX      @DPTR,A
    263                      /* Check number of bytes left in the Rx buffer */
    264                      bytesInRxBuffer = Hal_UART_RxBufLen(port);
   \   0000C7                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   0000C7   EE           MOV       A,R6
   \   0000C8   F9           MOV       R1,A
   \   0000C9   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   0000CC   EA           MOV       A,R2
   \   0000CD   FF           MOV       R7,A
    265          
    266                      /* If the remain of the data is there, read them all, otherwise, just read enough */
    267                      if (bytesInRxBuffer <= pMsgContent->len - tempDataLen)
   \   0000CE   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000D1   F8           MOV       R0,A
   \   0000D2   90....       MOV       DPTR,#tempDataLen
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   FA           MOV       R2,A
   \   0000D7   E8           MOV       A,R0
   \   0000D8   C3           CLR       C
   \   0000D9   9A           SUBB      A,R2
   \   0000DA   F8           MOV       R0,A
   \   0000DB   95E0         SUBB      A,0xE0 /* A   */
   \   0000DD   F9           MOV       R1,A
   \   0000DE   EF           MOV       A,R7
   \   0000DF   FA           MOV       R2,A
   \   0000E0   C3           CLR       C
   \   0000E1   E8           MOV       A,R0
   \   0000E2   9A           SUBB      A,R2
   \   0000E3   E9           MOV       A,R1
   \   0000E4   9400         SUBB      A,#0x0
   \   0000E6   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000E8   65D0         XRL       A,PSW
   \   0000EA   33           RLC       A
   \   0000EB   4010         JC        ??MT_UartProcessZToolData_8
    268                      {
    269                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], bytesInRxBuffer);
   \   0000ED                ; Setup parameters for call to function HalUARTRead
   \   0000ED   EF           MOV       A,R7
   \   0000EE   FC           MOV       R4,A
   \   0000EF   7D00         MOV       R5,#0x0
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   F8           MOV       R0,A
   \   0000F3   12....       LCALL     ?Subroutine2 & 0xFFFF
    270                          tempDataLen += bytesInRxBuffer;
   \                     ??CrossCallReturnLabel_2:
   \   0000F6   90....       MOV       DPTR,#tempDataLen
   \   0000F9   E0           MOVX      A,@DPTR
   \   0000FA   2F           ADD       A,R7
   \   0000FB   801C         SJMP      ??MT_UartProcessZToolData_9
    271                      }
    272                      else
    273                      {
    274                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], pMsgContent->len - tempDataLen);
   \                     ??MT_UartProcessZToolData_8:
   \   0000FD   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F583         MOV       DPH,A
   \   000105   8A82         MOV       DPL,R2
   \   000107   A3           INC       DPTR
   \   000108   A3           INC       DPTR
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   C3           CLR       C
   \   00010B   98           SUBB      A,R0
   \   00010C   FC           MOV       R4,A
   \   00010D   95E0         SUBB      A,0xE0 /* A   */
   \   00010F   FD           MOV       R5,A
   \   000110   12....       LCALL     ?Subroutine2 & 0xFFFF
    275                          tempDataLen += (pMsgContent->len - tempDataLen);
   \                     ??CrossCallReturnLabel_3:
   \   000113   12....       LCALL     ?Subroutine5 & 0xFFFF
    276                      }
   \                     ??CrossCallReturnLabel_9:
   \   000116   90....       MOV       DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_9:
   \   000119   F0           MOVX      @DPTR,A
    277                      /* If number of bytes read is equal to data length, time to move on to FCS */
    278                      if ( tempDataLen == pMsgContent->len )
   \   00011A   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00011D   F9           MOV       R1,A
   \   00011E   A3           INC       DPTR
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   F583         MOV       DPH,A
   \   000122   8982         MOV       DPL,R1
   \   000124   A3           INC       DPTR
   \   000125   A3           INC       DPTR
   \   000126   E0           MOVX      A,@DPTR
   \   000127   68           XRL       A,R0
   \   000128   6003         JZ        $+5
   \   00012A   02....       LJMP      ??MT_UartProcessZToolData_0 & 0xFFFF
    279                          state = FCS_STATE;
   \   00012D   90....       MOV       DPTR,#state
   \   000130   7403         MOV       A,#0x3
   \   000132   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    280                      break;
    281                  case FCS_STATE:
    282                      /* Make sure it's correct */
    283                      {
    284                          pMsgContent->fsc = ch;
   \                     ??MT_UartProcessZToolData_7:
   \   000135   85..82       MOV       DPL,?XSP + 0
   \   000138   85..83       MOV       DPH,?XSP + 1
   \   00013B   E0           MOVX      A,@DPTR
   \   00013C   C0E0         PUSH      A
   \   00013E   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000141   D0E0         POP       A
   \   000143   F0           MOVX      @DPTR,A
    285                          uint8 fcs = MT_UartCalcFCS(0, &pMsgContent->len, 1);
   \   000144   90....       MOV       DPTR,#pMsgContent
   \   000147   E0           MOVX      A,@DPTR
   \   000148   2402         ADD       A,#0x2
   \   00014A   F5..         MOV       ?V0,A
   \   00014C   A3           INC       DPTR
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   3400         ADDC      A,#0x0
   \   000150   F5..         MOV       ?V1,A
   \   000152                ; Setup parameters for call to function MT_UartCalcFCS
   \   000152   7C01         MOV       R4,#0x1
   \   000154   AA..         MOV       R2,?V0
   \   000156   FB           MOV       R3,A
   \   000157   7900         MOV       R1,#0x0
   \   000159   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   00015C   E9           MOV       A,R1
   \   00015D   F9           MOV       R1,A
    286                          fcs = MT_UartCalcFCS(fcs, pMsgContent->dataBody, pMsgContent->len);
   \   00015E                ; Setup parameters for call to function MT_UartCalcFCS
   \   00015E   85..82       MOV       DPL,?V0
   \   000161   85..83       MOV       DPH,?V1
   \   000164   E0           MOVX      A,@DPTR
   \   000165   FC           MOV       R4,A
   \   000166   90....       MOV       DPTR,#pMsgContent
   \   000169   E0           MOVX      A,@DPTR
   \   00016A   2403         ADD       A,#0x3
   \   00016C   FA           MOV       R2,A
   \   00016D   A3           INC       DPTR
   \   00016E   E0           MOVX      A,@DPTR
   \   00016F   3400         ADDC      A,#0x0
   \   000171   FB           MOV       R3,A
   \   000172   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   000175   E9           MOV       A,R1
   \   000176   F9           MOV       R1,A
    287                          if(fcs == ch)
   \   000177   85..82       MOV       DPL,?XSP + 0
   \   00017A   85..83       MOV       DPH,?XSP + 1
   \   00017D   E0           MOVX      A,@DPTR
   \   00017E   69           XRL       A,R1
   \   00017F   90....       MOV       DPTR,#pMsg
   \   000182   7005         JNZ       ??MT_UartProcessZToolData_10
    288                              osal_msg_send(App_TaskID, (byte *)pMsg);
   \   000184                ; Setup parameters for call to function osal_msg_send
   \   000184   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000187   8003         SJMP      ??CrossCallReturnLabel_11
    289                          else
    290                              osal_msg_deallocate((uint8 *)pMsg);
   \                     ??MT_UartProcessZToolData_10:
   \   000189                ; Setup parameters for call to function osal_msg_deallocate
   \   000189   12....       LCALL     ?Subroutine6 & 0xFFFF
    291                      }
    292                      /* Reset the state, send or discard the buffers at this point */
    293                      state = SOP_STATE;
   \                     ??CrossCallReturnLabel_11:
   \   00018C   90....       MOV       DPTR,#state
   \   00018F   E4           CLR       A
   \   000190   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    294                      break;
    295                  default:
    296                      break;
    297                  }
    298              }
    299          }
   \                     ??MT_UartProcessZToolData_3:
   \   000193   7401         MOV       A,#0x1
   \   000195   12....       LCALL     ?DEALLOC_XSTACK8
   \   000198   7F02         MOV       R7,#0x2
   \   00019A   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F583         MOV       DPH,A
   \   000009   8882         MOV       DPL,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002                ; Setup parameters for call to function HalUARTRead
   \   000002   90....       MOV       DPTR,#pMsgContent
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000007   AA82         MOV       R2,DPL
   \   000009   AB83         MOV       R3,DPH
   \   00000B   EE           MOV       A,R6
   \   00000C   F9           MOV       R1,A
   \   00000D   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   28           ADD       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   3400         ADDC      A,#0x0
   \   000006   8A82         MOV       DPL,R2
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartRegisterTaskID::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartCalcFCS::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartProcessZToolData1::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartProcessZToolData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    300          #if 0
    301          void MT_UartProcessAppData ( uint8 port, uint8 event )
    302          {
    303             uint8  *bytesInRxBuffer;
    304            static uint8 *msg;
    305          
    306            (void)event;  // Intentionally unreferenced parameter
    307            msg = (uint8 *)osal_msg_allocate(5);
    308            if(msg){
    309              bytesInRxBuffer = msg;
    310              *bytesInRxBuffer ++ = CMD_SERIAL_MSG;
    311            }
    312            while (Hal_UART_RxBufLen(port))
    313            {
    314              HalUARTRead (port, bytesInRxBuffer , 5);
    315              osal_msg_send( App_TaskID, (byte *)msg );
    316            }
    317          
    318          }
    319          #endif
    320          
    321          #endif
    322          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    323          /***************************************************************************************************
    324           * @fn      MT_UartProcessZAppData
    325           *
    326           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    327           *          |  1  |  2   |       1         |  1   |
    328           *
    329           *          Parses the data and determine either is SPI or just simply serial data
    330           *          then send the data to correct place (MT or APP)
    331           *
    332           * @param   port    - UART port
    333           *          event   - Event that causes the callback
    334           *
    335           *
    336           * @return  None
    337           ***************************************************************************************************/
    338          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    339          {
    340          
    341            osal_event_hdr_t  *msg_ptr;
    342            uint16 length = 0;
    343            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    344          
    345            /*
    346               If maxZAppBufferLength is 0 or larger than current length
    347               the entire length of the current buffer is returned.
    348            */
    349            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    350            {
    351              length = MT_UartMaxZAppBufLen;
    352            }
    353            else
    354            {
    355              length = rxBufLen;
    356            }
    357          
    358            /* Verify events */
    359            if (event == HAL_UART_TX_FULL)
    360            {
    361              // Do something when TX if full
    362              return;
    363            }
    364          
    365            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    366            {
    367              if ( App_TaskID )
    368              {
    369                /*
    370                   If Application is ready to receive and there is something
    371                   in the Rx buffer then send it up
    372                */
    373                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    374                {
    375                  /* Disable App flow control until it processes the current data */
    376                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    377          
    378                  /* 2 more bytes are added, 1 for CMD type, other for length */
    379                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    380                  if ( msg_ptr )
    381                  {
    382                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    383                    msg_ptr->status = length;
    384          
    385                    /* Read the data of Rx buffer */
    386                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    387          
    388                    /* Send the raw data to application...or where ever */
    389                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    390                  }
    391                }
    392              }
    393            }
    394          }
    395          
    396          /***************************************************************************************************
    397           * @fn      SPIMgr_ZAppBufferLengthRegister
    398           *
    399           * @brief
    400           *
    401           * @param   maxLen - Max Length that the application wants at a time
    402           *
    403           * @return  None
    404           *
    405           ***************************************************************************************************/
    406          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    407          {
    408            /* If the maxLen is larger than the RX buff, something is not right */
    409            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    410              MT_UartMaxZAppBufLen = maxLen;
    411            else
    412              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    413          }
    414          
    415          /***************************************************************************************************
    416           * @fn      SPIMgr_AppFlowControl
    417           *
    418           * @brief
    419           *
    420           * @param   status - ready to send or not
    421           *
    422           * @return  None
    423           *
    424           ***************************************************************************************************/
    425          void MT_UartAppFlowControl ( bool status )
    426          {
    427          
    428            /* Make sure only update if needed */
    429            if (status != MT_UartZAppRxStatus )
    430            {
    431              MT_UartZAppRxStatus = status;
    432            }
    433          
    434            /* App is ready to read again, ProcessZAppData have to be triggered too */
    435            if (status == MT_UART_ZAPP_RX_READY)
    436            {
    437              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    438            }
    439          
    440          }
    441          
    442          #endif //ZAPP
    443          
    444          /***************************************************************************************************
    445          ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     20   MT_UartCalcFCS
      2     29   MT_UartInit
        2     29   -> HalUARTOpen
      1     11   MT_UartProcessZToolData
        0     11   -> HalUARTRead
        0     11   -> Hal_UART_RxBufLen
        0     11   -> MT_UartCalcFCS
        0     11   -> osal_msg_allocate
        0     11   -> osal_msg_deallocate
        0     11   -> osal_msg_send
      1    140   MT_UartProcessZToolData1
        0    140   -> HalUARTRead
        0    140   -> Hal_UART_RxBufLen
        0    140   -> osal_msg_allocate
        0    140   -> osal_msg_deallocate
        0    140   -> osal_msg_send
      2      0   MT_UartRegisterTaskID


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?Subroutine0
      38  ?Subroutine1
      12  ?Subroutine10
      17  ?Subroutine2
      14  ?Subroutine3
      17  ?Subroutine4
       7  ?Subroutine5
       9  ?Subroutine6
       7  ?Subroutine7
       4  ?Subroutine8
      14  ?Subroutine9
       1  App_TaskID
      33  MT_UartCalcFCS
       6  MT_UartCalcFCS::?relay
     110  MT_UartInit
       6  MT_UartInit::?relay
     413  MT_UartProcessZToolData
     157  MT_UartProcessZToolData1
       6  MT_UartProcessZToolData1::?relay
       6  MT_UartProcessZToolData::?relay
      11  MT_UartRegisterTaskID
       6  MT_UartRegisterTaskID::?relay
       2  pMsg
       2  pMsgContent
       1  state
       1  tempDataLen

 
 870 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   7 bytes in segment XDATA_Z
 
  30 bytes of CODE     memory
 870 bytes of HUGECODE memory
   7 bytes of XDATA    memory

Errors: none
Warnings: none
