###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               14/Jul/2019  19:08:43
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Components\hal\target\CC2530EB\IR.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWDEFD.tmp
#        (D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Components\hal\target\CC2530EB\IR.c
#        -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D SAPP_ZSTACK -lC
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\RouterEB\List
#        -lA
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\RouterEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\RouterEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4545
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\ -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\Source\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mt\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\RouterEB\List\IR.lst
#    Object file        =  
#        D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Projects\SappWsn\RouterEB\Obj\IR.r51
#
###############################################################################

D:\课设勿动\ZStack-CC2530-r200\Zigbee_NetWork\Components\hal\target\CC2530EB\IR.c
      1          /***********************************************************
      2          **  FileName:         IR.c
      3          **  Introductions:    Sunplusapp CC2530 ZigBee Node IR Romoter Signal Send Functions
      4          **  Last Modify time: 2013.05.21
      5          **  Modify:           修改红外编码发送，优化时序，添加注释
      6          **  Author:           GuoZhenjiang <zhenjiang.guo@sunplusapp.com>
      7          ***********************************************************/
      8          
      9          #include "IR.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xaf
   \   unsigned char volatile __sfr T1STAT
   \                     T1STAT:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcb
   \   unsigned char volatile __sfr T3CTL
   \                     T3CTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcc
   \   unsigned char volatile __sfr T3CCTL0
   \                     T3CCTL0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xcd
   \   unsigned char volatile __sfr T3CC0
   \                     T3CC0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xd8
   \   union <unnamed> volatile __sfr _A_TIMIF
   \                     _A_TIMIF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xda
   \   unsigned char volatile __sfr T1CC0L
   \                     T1CC0L:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xdb
   \   unsigned char volatile __sfr T1CC0H
   \                     T1CC0H:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe4
   \   unsigned char volatile __sfr T1CTL
   \                     T1CTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe5
   \   unsigned char volatile __sfr T1CCTL0
   \                     T1CCTL0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf4
   \   unsigned char volatile __sfr P1SEL
   \                     P1SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf5
   \   unsigned char volatile __sfr P2SEL
   \                     P2SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     10          #include "OSAL.h"
     11          
     12          #if defined(HAL_IRENC) && (HAL_IRENC == TRUE)
     13          
     14          // 定时器1中自增量,控制每一位编码的周期

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     15          volatile uint16  T1_80usCnt = 0;
   \                     T1_80usCnt:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     16          
     17          // Timer1红外编码初始化
     18          void IRSend_T1_Init(void);
     19          // Timer3红外编码初始化
     20          void IRSend_T3_Init(void);
     21          // Timer1 & Timer3 中断处理函数声明
     22          __near_func __interrupt void IRSend_T1IntHandle(void);
     23          __near_func __interrupt void IRSend_T3IntHandle(void);
     24          
     25          /***********************************************************
     26          **  函数名称: GenIR
     27          **  实现功能: 系统时钟设置
     28          **  入口参数: IRData:   红外编码数据首地址
     29          **            Mode:     引导码分类:1 周期9ms    2:周期13.56ms
     30          **            CodeLen:  编码位数(bit,不是Byte)
     31          **  返回结果: 0:发送失败    1:发送成功
     32          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     33          int GenIR(uint8 *IRData , uint8 Mode , uint8 CodeLen )
   \                     GenIR:
     34          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
     35              uint16  GuideCodeLen=0;
   \   000009   75..00       MOV       ?V0,#0x0
     36              static IRSendSta_t IRSendSta = IRSta_Guide;
     37              static uint8 cntByte=0, cntbit=0, bitNum;
     38              bitNum = CodeLen;       //保存位数
   \   00000C   EC           MOV       A,R4
   \   00000D   90....       MOV       DPTR,#??bitNum
   \   000010   F0           MOVX      @DPTR,A
     39          
     40              if(Mode == 1)
   \   000011   7401         MOV       A,#0x1
   \   000013   69           XRL       A,R1
   \   000014   7005         JNZ       ??GenIR_0
     41                GuideCodeLen = 56;//226;   引导码长度（4.5ms、4.5ms）
   \   000016   75..38       MOV       ?V0,#0x38
   \   000019   8008         SJMP      ??GenIR_1
     42              else if(Mode == 2)
   \                     ??GenIR_0:
   \   00001B   7402         MOV       A,#0x2
   \   00001D   69           XRL       A,R1
   \   00001E   7003         JNZ       ??GenIR_1
     43                GuideCodeLen = 114;   //引导码长度（9ms、4.5ms）
   \   000020   75..72       MOV       ?V0,#0x72
     44          
     45              IRSend_T1_Init();
   \                     ??GenIR_1:
   \   000023                ; Setup parameters for call to function IRSend_T1_Init
   \   000023   12....       LCALL     `??IRSend_T1_Init::?relay`; Banked call to: IRSend_T1_Init
     46              IRSend_T3_Init();
   \   000026                ; Setup parameters for call to function IRSend_T3_Init
   \   000026   12....       LCALL     `??IRSend_T3_Init::?relay`; Banked call to: IRSend_T3_Init
     47              IR_SEL_IOOUT;
   \   000029   12....       LCALL     ?Subroutine2 & 0xFFFF
     48              CLR_IOB_BIT;
     49              IRSendSta = IRSta_Guide;
     50              T1_80usCnt = 0;
   \                     ??CrossCallReturnLabel_4:
   \   00002C   90....       MOV       DPTR,#T1_80usCnt
   \   00002F   E4           CLR       A
   \   000030   F0           MOVX      @DPTR,A
   \   000031   A3           INC       DPTR
   \   000032   F0           MOVX      @DPTR,A
     51              IR_SEL_T3PWM;
   \                     ??GenIR_2:
   \   000033   43F408       ORL       0xf4,#0x8
   \   000036   8003         SJMP      ??CrossCallReturnLabel_5
     52              while(1)
     53              {
     54                  // 查询红外编码发送状态
     55                  switch(IRSendSta)
     56                  {
     57                      // 引导码阶段
     58                  case IRSta_Guide:	
     59                      // 引导码4.5ms或9ms载波阶段
     60                      if(T1_80usCnt <= GuideCodeLen)
     61                      {
     62                          IRSendSta = IRSta_Guide;
     63                          IR_SEL_T3PWM;
     64                      }
     65                      // 引导码4.5ms低电平阶段
     66                      else if((T1_80usCnt > GuideCodeLen) && (T1_80usCnt <= GuideCodeLen+56))
     67                      {
     68                          IRSendSta = IRSta_Guide;
     69                          IR_SEL_IOOUT;
   \                     ??GenIR_3:
   \   000038   12....       LCALL     ?Subroutine2 & 0xFFFF
     70                          CLR_IOB_BIT;
     71                      }
   \                     ??CrossCallReturnLabel_5:
   \   00003B   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00003E   50F3         JNC       ??GenIR_2
   \   000040   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000043   5017         JNC       ??GenIR_4
   \   000045   E5..         MOV       A,?V0
   \   000047   2438         ADD       A,#0x38
   \   000049   FA           MOV       R2,A
   \   00004A   E4           CLR       A
   \   00004B   3400         ADDC      A,#0x0
   \   00004D   FB           MOV       R3,A
   \   00004E   90....       MOV       DPTR,#T1_80usCnt
   \   000051   E0           MOVX      A,@DPTR
   \   000052   F8           MOV       R0,A
   \   000053   A3           INC       DPTR
   \   000054   E0           MOVX      A,@DPTR
   \   000055   F9           MOV       R1,A
   \   000056   EA           MOV       A,R2
   \   000057   98           SUBB      A,R0
   \   000058   EB           MOV       A,R3
   \   000059   99           SUBB      A,R1
   \   00005A   50DC         JNC       ??GenIR_3
     72                      // 引导码发送完毕,准备发送数据位
     73                      else
     74                      {
     75                          IRSendSta = IRSta_T3PWM;
     76                          IR_SEL_T3PWM;
   \                     ??GenIR_4:
   \   00005C   12....       LCALL     ?Subroutine4 & 0xFFFF
     77                          T1_80usCnt = 0;
     78                      }
     79                      break;
     80                      // 数据位中的位0、位1的0.56ms的38kHz载波阶段
     81                  case IRSta_T3PWM:
     82                      if(T1_80usCnt >= 7)     // 7 * 80us = 560us
   \                     ??CrossCallReturnLabel_9:
   \   00005F   90....       MOV       DPTR,#T1_80usCnt
   \   000062   C3           CLR       C
   \   000063   E0           MOVX      A,@DPTR
   \   000064   9407         SUBB      A,#0x7
   \   000066   A3           INC       DPTR
   \   000067   E0           MOVX      A,@DPTR
   \   000068   9400         SUBB      A,#0x0
   \   00006A   40F3         JC        ??CrossCallReturnLabel_9
     83                      {
     84                          IR_SEL_IOOUT;
   \   00006C   12....       LCALL     ?Subroutine1 & 0xFFFF
     85                          CLR_IOB_BIT;
     86                          IRSendSta = IRSta_Data0;
     87                      }
     88                      break;
     89                      // 数据位中的位0、位1的低电平持续阶段
     90                  case IRSta_Data0:
     91                      //发送数据0,低电平持续 0.565ms。
     92                      if(!(IRData[cntByte] & (0x80 >> (cntbit % 8))))
   \                     ??CrossCallReturnLabel_2:
   \   00006F   E0           MOVX      A,@DPTR
   \   000070   5407         ANL       A,#0x7
   \   000072   F8           MOV       R0,A
   \   000073   7480         MOV       A,#-0x80
   \   000075   B80002       CJNE      R0,#0x0,??GenIR_5
   \   000078   8004         SJMP      ??GenIR_6
   \                     ??GenIR_5:
   \   00007A   C3           CLR       C
   \   00007B   13           RRC       A
   \   00007C   D8FC         DJNZ      R0,??GenIR_5
   \                     ??GenIR_6:
   \   00007E   FA           MOV       R2,A
   \   00007F   90....       MOV       DPTR,#??cntByte
   \   000082   E0           MOVX      A,@DPTR
   \   000083   F8           MOV       R0,A
   \   000084   EE           MOV       A,R6
   \   000085   28           ADD       A,R0
   \   000086   F582         MOV       DPL,A
   \   000088   E4           CLR       A
   \   000089   3F           ADDC      A,R7
   \   00008A   F583         MOV       DPH,A
   \   00008C   E0           MOVX      A,@DPTR
   \   00008D   5A           ANL       A,R2
   \   00008E   90....       MOV       DPTR,#T1_80usCnt
   \   000091   C3           CLR       C
   \   000092   7010         JNZ       ??GenIR_7
     93                      {
     94                          if(T1_80usCnt >= 14)
   \   000094   E0           MOVX      A,@DPTR
   \   000095   940E         SUBB      A,#0xe
   \   000097   A3           INC       DPTR
   \   000098   E0           MOVX      A,@DPTR
   \   000099   9400         SUBB      A,#0x0
   \   00009B   401B         JC        ??GenIR_8
     95                          {
     96                              IR_SEL_T3PWM;
   \   00009D   12....       LCALL     ?Subroutine0 & 0xFFFF
     97                              T1_80usCnt = 0;
     98                              cntbit++;
     99                              if(0 == (cntbit % 8))
    100                                  cntByte++;
    101                          }
    102                      }
   \                     ??CrossCallReturnLabel_0:
   \   0000A0   7016         JNZ       ??GenIR_8
   \   0000A2   800E         SJMP      ??GenIR_9
    103                      //发送数据1,低电平持续 1.685ms。
    104                      else if(IRData[cntByte] & (0x80 >> (cntbit % 8)))
    105                      {
    106                          if(T1_80usCnt >= 28)
   \                     ??GenIR_7:
   \   0000A4   E0           MOVX      A,@DPTR
   \   0000A5   941C         SUBB      A,#0x1c
   \   0000A7   A3           INC       DPTR
   \   0000A8   E0           MOVX      A,@DPTR
   \   0000A9   9400         SUBB      A,#0x0
   \   0000AB   400B         JC        ??GenIR_8
    107                          {				
    108                              IR_SEL_T3PWM;
   \   0000AD   12....       LCALL     ?Subroutine0 & 0xFFFF
    109                              T1_80usCnt = 0;
    110                              cntbit++;
    111                              if(0 == (cntbit % 8))
   \                     ??CrossCallReturnLabel_1:
   \   0000B0   7006         JNZ       ??GenIR_8
    112                                  cntByte++;
   \                     ??GenIR_9:
   \   0000B2   90....       MOV       DPTR,#??cntByte
   \   0000B5   E0           MOVX      A,@DPTR
   \   0000B6   04           INC       A
   \   0000B7   F0           MOVX      @DPTR,A
    113                          }
    114                      }	
    115                      // 发送完毕?
    116                      if(cntbit >= bitNum)	
   \                     ??GenIR_8:
   \   0000B8   90....       MOV       DPTR,#??bitNum
   \   0000BB   E0           MOVX      A,@DPTR
   \   0000BC   F8           MOV       R0,A
   \   0000BD   90....       MOV       DPTR,#??cntbit
   \   0000C0   E0           MOVX      A,@DPTR
   \   0000C1   C3           CLR       C
   \   0000C2   98           SUBB      A,R0
   \   0000C3   409A         JC        ??CrossCallReturnLabel_9
    117                          IRSendSta = IRSta_Stop;
   \   0000C5   90....       MOV       DPTR,#??IRSendSta
   \   0000C8   7403         MOV       A,#0x3
   \   0000CA   F0           MOVX      @DPTR,A
    118                      // 继续发送?
    119                      else
    120                          IRSendSta = IRSta_T3PWM;
    121                      break;
    122                      // 红外编码数据部分发送完毕
    123                  case IRSta_Stop:
    124                      // 一组编码发送完毕  结束位是 0.56ms 的 38K 载波
    125                      while(T1_80usCnt < 7)
   \                     ??GenIR_10:
   \   0000CB   90....       MOV       DPTR,#T1_80usCnt
   \   0000CE   C3           CLR       C
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   9407         SUBB      A,#0x7
   \   0000D2   A3           INC       DPTR
   \   0000D3   E0           MOVX      A,@DPTR
   \   0000D4   9400         SUBB      A,#0x0
   \   0000D6   40F3         JC        ??GenIR_10
    126                          ;
    127                      STOP_T1_T3; // stop T1 & T3
   \   0000D8   75CB00       MOV       0xcb,#0x0
   \   0000DB   75E400       MOV       0xe4,#0x0
    128                      T1_80usCnt = 0;
   \   0000DE   90....       MOV       DPTR,#T1_80usCnt
   \   0000E1   E4           CLR       A
   \   0000E2   F0           MOVX      @DPTR,A
   \   0000E3   A3           INC       DPTR
   \   0000E4   F0           MOVX      @DPTR,A
    129                      IR_SEL_IOOUT;
   \   0000E5   12....       LCALL     ?Subroutine1 & 0xFFFF
    130                      CLR_IOB_BIT;
    131                      cntbit = 0;
   \                     ??CrossCallReturnLabel_3:
   \   0000E8   F0           MOVX      @DPTR,A
    132                      cntByte = 0;
   \   0000E9   90....       MOV       DPTR,#??cntByte
   \   0000EC   F0           MOVX      @DPTR,A
    133                      return 1;
   \   0000ED   7A01         MOV       R2,#0x1
   \   0000EF   FB           MOV       R3,A
   \   0000F0   7F04         MOV       R7,#0x4
   \   0000F2   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   0000F5                REQUIRE P1SEL
   \   0000F5                REQUIRE P1DIR
   \   0000F5                REQUIRE _A_P1
   \   0000F5                REQUIRE T3CTL
   \   0000F5                REQUIRE T1CTL
    134                      break;
    135                  default:
    136                      return 0;
    137                      break;
    138                  }							
    139              }
    140          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   90....       MOV       DPTR,#T1_80usCnt
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F9           MOV       R1,A
   \   000008   C3           CLR       C
   \   000009   E5..         MOV       A,?V0
   \   00000B   98           SUBB      A,R0
   \   00000C   E4           CLR       A
   \   00000D   99           SUBB      A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000003   90....       MOV       DPTR,#??cntbit
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000003   90....       MOV       DPTR,#??cntbit
   \   000006   E0           MOVX      A,@DPTR
   \   000007   04           INC       A
   \   000008   F0           MOVX      @DPTR,A
   \   000009   5407         ANL       A,#0x7
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   43F408       ORL       0xf4,#0x8
   \   000003   90....       MOV       DPTR,#T1_80usCnt
   \   000006   E4           CLR       A
   \   000007   F0           MOVX      @DPTR,A
   \   000008   A3           INC       DPTR
   \   000009   F0           MOVX      @DPTR,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   53F4F7       ANL       0xf4,#0xf7
   \   000003   43FE08       ORL       0xfe,#0x8
   \   000006   C293         CLR       0x90.3
   \   000008   22           RET

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??IRSendSta:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??cntByte:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??cntbit:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??bitNum:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    141          
    142          /***********************************************************
    143          **  函数名称: IRSend_T1_Init
    144          **  实现功能: 红外编码发送定时器1初始化
    145          **  入口参数: None
    146          **  返回结果: None
    147          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    148          void IRSend_T1_Init(void)
   \                     IRSend_T1_Init:
    149          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    150              T1CTL = 0x0E;       // f = 32MHz / 128 = 250 000Hz, T = 4us;模模式,从0~T1CC0反复计数。
   \   000004   75E40E       MOV       0xe4,#0xe
    151              T1CCTL0 = 0x44;     // Timer1通道0中断允许,比较匹配模式,比较比配时输出置位。
   \   000007   75E544       MOV       0xe5,#0x44
    152              T1CC0L = 19;        // 先写T1CC0L,再写T1CC0H,T1CNT=0时更新。 4us*20 = 80us;
   \   00000A   75DA13       MOV       0xda,#0x13
    153              T1CC0H = 0;
   \   00000D   75DB00       MOV       0xdb,#0x0
    154              TIMIF |= BIT_1(6);  // TIMIF.T1OVFIM Timer1溢出中断允许
   \   000010   D2DE         SETB      0xd8.6
    155              IEN1 |= BIT_1(1);   // IEN1.T1IE Timer1总中断允许
   \   000012   D2B9         SETB      0xb8.1
    156              EA = 1;             // 打开全局总中断
   \   000014   D2AF         SETB      0xa8.7
    157              T1_80usCnt = 0;     // 80us溢出中断自增量清零
   \   000016   90....       MOV       DPTR,#T1_80usCnt
   \   000019   E4           CLR       A
   \   00001A   F0           MOVX      @DPTR,A
   \   00001B   A3           INC       DPTR
   \   00001C   F0           MOVX      @DPTR,A
    158          }
   \   00001D   D083         POP       DPH
   \   00001F   D082         POP       DPL
   \   000021   02....       LJMP      ?BRET
   \   000024                REQUIRE T1CTL
   \   000024                REQUIRE T1CCTL0
   \   000024                REQUIRE T1CC0L
   \   000024                REQUIRE T1CC0H
   \   000024                REQUIRE _A_TIMIF
   \   000024                REQUIRE _A_IEN1
   \   000024                REQUIRE _A_IEN0
    159          
    160          /***********************************************************
    161          **  函数名称: IRSend_T3_Init
    162          **  实现功能: 红外编码发送定时器3初始化
    163          **  入口参数: None
    164          **  返回结果: None
    165          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    166          void IRSend_T3_Init(void)
   \                     IRSend_T3_Init:
    167          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    168              P1SEL |= BIT_1(3);      // P1.3 us as T3 PWM Out Pin.
   \   000000   43F408       ORL       0xf4,#0x8
    169              T3CTL = 0x02;           // T3CTL.MODE[10] 模模式,从0~T3CC0反复计数
   \   000003   75CB02       MOV       0xcb,#0x2
    170              T3CTL |= BIT_1(5);      // T3CTL.MODE[001] f = 32MHz / 2 = 16MHz;
   \   000006   43CB20       ORL       0xcb,#0x20
    171              T3CCTL0 |= BIT_1(2);    // T3CCTL0.MODE 输出比较比配模式
   \   000009   43CC04       ORL       0xcc,#0x4
    172              T3CCTL0 |= BIT_1(4);    // T3CCTL0.CMP[010] 比较匹配时,输出取反
   \   00000C   43CC10       ORL       0xcc,#0x10
    173          
    174              T3CC0 = 208;            // Timer3通道0输出比较匹配上限值,16MHz / 208 = 76923.076923Hz; 76923 / 2 =38k(比较匹配时取反).
   \   00000F   75CDD0       MOV       0xcd,#-0x30
    175              T3CTL |= BIT_1(4);      // T3CTL.START 启动Timer3
   \   000012   43CB10       ORL       0xcb,#0x10
    176              P2SEL |= BIT_1(5);      // P2SEL.PRI2P1 当USART1和Timer3占用相同引脚,Timer3优先。
   \   000015   43F520       ORL       0xf5,#0x20
    177              T3CCTL0 |= BIT_1(6);    // T3CCTL0.IM Timer3通道0中断允许。
   \   000018   43CC40       ORL       0xcc,#0x40
    178              IEN1 |= BIT_1(3);       // IEN1.T3IE Timer3总中断允许。
   \   00001B   D2BB         SETB      0xb8.3
    179              EA = 1;                 // 全局总中断允许。
   \   00001D   D2AF         SETB      0xa8.7
    180          }
   \   00001F   02....       LJMP      ?BRET
   \   000022                REQUIRE P1SEL
   \   000022                REQUIRE T3CTL
   \   000022                REQUIRE T3CCTL0
   \   000022                REQUIRE T3CC0
   \   000022                REQUIRE P2SEL
   \   000022                REQUIRE _A_IEN1
   \   000022                REQUIRE _A_IEN0
    181          
    182          /***********************************************************
    183          **  函数名称: IRSendInit
    184          **  实现功能: 红外编码发送初始化
    185          **  入口参数: None
    186          **  返回结果: None
    187          ***********************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    188          void IRSendInit(void)
   \                     IRSendInit:
    189          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    190              IR_SEL_IOOUT;
   \   000000   12....       LCALL     ?Subroutine2 & 0xFFFF
    191              CLR_IOB_BIT;
    192          }
   \                     ??CrossCallReturnLabel_6:
   \   000003   02....       LJMP      ?BRET
   \   000006                REQUIRE P1SEL
   \   000006                REQUIRE P1DIR
   \   000006                REQUIRE _A_P1
    193          
    194          /***********************************************************
    195          **  函数名称: IRSend_T1IntHandle
    196          **  实现功能: Timer1 红外编码发送中的中断处理函数
    197          **  入口参数: None
    198          **  返回结果: None
    199          ***********************************************************/
    200          #pragma vector = T1_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    201          __interrupt void IRSend_T1IntHandle(void)
   \                     IRSend_T1IntHandle:
    202          {
   \   000000   C0E0         PUSH      A
   \   000002   C0D0         PUSH      PSW
   \   000004   C082         PUSH      DPL
   \   000006   C083         PUSH      DPH
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    203              T1STAT &= BIT_0(5);     // T1STAT.OVFIF 清除Timer1溢出中断标志
   \   000008   53AFDF       ANL       0xaf,#0xdf
    204              T1STAT &= BIT_0(1);     // T1STAT.CH0IF 清除Timer1通道0中断标志
   \   00000B   53AFFD       ANL       0xaf,#0xfd
    205              IRCON &= BIT_0(1);      // IRCON.T1IF   清除Timer1总中断标志
   \   00000E   C2C1         CLR       0xc0.1
    206              T1_80usCnt++;
   \   000010   90....       MOV       DPTR,#T1_80usCnt
   \   000013   E0           MOVX      A,@DPTR
   \   000014   2401         ADD       A,#0x1
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   E0           MOVX      A,@DPTR
   \   000019   3400         ADDC      A,#0x0
   \   00001B   F0           MOVX      @DPTR,A
    207          }
   \   00001C   D083         POP       DPH
   \   00001E   D082         POP       DPL
   \   000020   D0D0         POP       PSW
   \   000022   D0E0         POP       A
   \   000024   32           RETI
   \   000025                REQUIRE T1STAT
   \   000025                REQUIRE _A_IRCON
    208          
    209          /***********************************************************
    210          **  函数名称: IRSend_T3IntHandle
    211          **  实现功能: Timer3 红外编码发送中的中断处理函数
    212          **  入口参数: None
    213          **  返回结果: None
    214          ***********************************************************/
    215          #pragma vector = T3_VECTOR

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    216          __near_func __interrupt void IRSend_T3IntHandle(void)
   \                     IRSend_T3IntHandle:
    217          {
   \   000000                ; Saved register size: 1
   \   000000                ; Auto size: 0
    218              TIMIF &= BIT_0(1);      // TIMIF.T3CH0IF
   \   000000   C2D9         CLR       0xd8.1
    219          }
   \   000002   32           RETI
   \   000003                REQUIRE _A_TIMIF

   \                                 In  segment INTVEC, offset 0x4b, root
   \                     `??IRSend_T1IntHandle::??INTVEC 75`:
   \   00004B   02....       LJMP       (IRSend_T1IntHandle)

   \                                 In  segment INTVEC, offset 0x5b, root
   \                     `??IRSend_T3IntHandle::??INTVEC 91`:
   \   00005B   02....       LJMP       (IRSend_T3IntHandle)

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??GenIR::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    GenIR

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRSend_T1_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSend_T1_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRSend_T3_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSend_T3_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??IRSendInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    IRSendInit
    220          
    221          
    222          #endif  // defined(HAL_IRENC) && (HAL_IRENC == TRUE)

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     12   GenIR
        0     12   -> IRSend_T1_Init
        0     12   -> IRSend_T3_Init
      0      0   IRSendInit
      4      0   IRSend_T1IntHandle
      2     12   IRSend_T1_Init
      1      0   IRSend_T3IntHandle
      0     12   IRSend_T3_Init


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?Subroutine0
       7  ?Subroutine1
       4  ?Subroutine2
      15  ?Subroutine3
      11  ?Subroutine4
       9  ?Subroutine5
     245  GenIR
       6  GenIR::?relay
       6  IRSendInit
       6  IRSendInit::?relay
       1  IRSendSta
      37  IRSend_T1IntHandle
       3  IRSend_T1IntHandle::??INTVEC 75
      36  IRSend_T1_Init
       6  IRSend_T1_Init::?relay
       3  IRSend_T3IntHandle
       3  IRSend_T3IntHandle::??INTVEC 91
      34  IRSend_T3_Init
       6  IRSend_T3_Init::?relay
       1  P1DIR
       1  P1SEL
       1  P2SEL
       1  T1CC0H
       1  T1CC0L
       1  T1CCTL0
       1  T1CTL
       1  T1STAT
       2  T1_80usCnt
       1  T3CC0
       1  T3CCTL0
       1  T3CTL
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       1  _A_P1
       1  _A_TIMIF
       1  bitNum
       1  cntByte
       1  cntbit

 
 379 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
  40 bytes in segment NEAR_CODE
  16 bytes in segment SFR_AN
   6 bytes in segment XDATA_Z
 
  64 bytes of CODE     memory (+  6 bytes shared)
   0 bytes of DATA     memory (+ 16 bytes shared)
 379 bytes of HUGECODE memory
   6 bytes of XDATA    memory

Errors: none
Warnings: none
