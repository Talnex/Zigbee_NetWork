###############################################################################
#
# IAR C/C++ Compiler V10.20.1.5333 for 8051               04/Sep/2019  16:42:52
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Components\mt\MT_UART.c
#    Command line       =  
#        -f C:\Users\talnex\AppData\Local\Temp\EW8337.tmp
#        (\\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Components\mt\MT_UART.c
#        -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D SAPP_ZSTACK -lC
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\RouterEB\List
#        -lA
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\RouterEB\List
#        --diag_suppress Pe001,Pa010 -o
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\RouterEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4545
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\ -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\Source\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\mt\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\RouterEB\List\MT_UART.lst
#    Object file        =  
#        \\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Projects\SappWsn\RouterEB\Obj\MT_UART.r51
#
###############################################################################

\\Mac\Home\Documents\GitHub\Kraken\Zigbee_NetWork\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define LEN_STATE      0x01
     61          #define DATA_STATE     0x02
     62          #define FCS_STATE      0x03
     63          
     64          /***************************************************************************************************
     65           *                                         GLOBAL VARIABLES
     66           ***************************************************************************************************/
     67          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     68          uint8 App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     69          
     70          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          uint8 state = SOP_STATE;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          mtUserSerialMsg_t   *pMsgContent;
   \                     pMsgContent:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     75          
     76          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     77          uint16  MT_UartMaxZAppBufLen;
     78          bool    MT_UartZAppRxStatus;
     79          #endif
     80          
     81          
     82          /***************************************************************************************************
     83           *                                          LOCAL FUNCTIONS
     84           ***************************************************************************************************/
     85          
     86          /***************************************************************************************************
     87           * @fn      MT_UartInit
     88           *
     89           * @brief   Initialize MT with UART support
     90           *
     91           * @param   None
     92           *
     93           * @return  None
     94          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     95          void MT_UartInit ()
   \                     MT_UartInit:
     96          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV       A,#-0x1d
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
     97            halUARTCfg_t uartConfig;
     98          
     99            /* Initialize APP ID */
    100            App_TaskID = 0;
   \   000009   90....       MOV       DPTR,#App_TaskID
   \   00000C   E4           CLR       A
   \   00000D   F0           MOVX      @DPTR,A
    101          
    102            /* UART Configuration */
    103            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    104            uartConfig.baudRate             = HAL_UART_BR_9600;
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   E4           CLR       A
   \   00001A   F0           MOVX      @DPTR,A
    105            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
   \   00001B   7402         MOV       A,#0x2
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   E4           CLR       A
   \   000021   F0           MOVX      @DPTR,A
    106            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000022   7403         MOV       A,#0x3
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   7440         MOV       A,#0x40
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   E4           CLR       A
   \   00002C   F0           MOVX      @DPTR,A
    107            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002D   740A         MOV       A,#0xa
   \   00002F   12....       LCALL     ?XSTACK_DISP0_8
   \   000032   7480         MOV       A,#-0x80
   \   000034   F0           MOVX      @DPTR,A
   \   000035   A3           INC       DPTR
   \   000036   E4           CLR       A
   \   000037   F0           MOVX      @DPTR,A
    108            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000038   7412         MOV       A,#0x12
   \   00003A   12....       LCALL     ?XSTACK_DISP0_8
   \   00003D   7480         MOV       A,#-0x80
   \   00003F   F0           MOVX      @DPTR,A
   \   000040   A3           INC       DPTR
   \   000041   E4           CLR       A
   \   000042   F0           MOVX      @DPTR,A
    109            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000043   7405         MOV       A,#0x5
   \   000045   12....       LCALL     ?XSTACK_DISP0_8
   \   000048   7406         MOV       A,#0x6
   \   00004A   F0           MOVX      @DPTR,A
    110            uartConfig.intEnable            = TRUE;
   \   00004B   7416         MOV       A,#0x16
   \   00004D   12....       LCALL     ?XSTACK_DISP0_8
   \   000050   7401         MOV       A,#0x1
   \   000052   F0           MOVX      @DPTR,A
    111          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    112            uartConfig.callBackFunc         = MT_UartProcessZToolData1;
   \   000053   741B         MOV       A,#0x1b
   \   000055   12....       LCALL     ?XSTACK_DISP0_8
   \   000058   74..         MOV       A,#`??MT_UartProcessZToolData1::?relay` & 0xff
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   74..         MOV       A,#(`??MT_UartProcessZToolData1::?relay` >> 8) & 0xff
   \   00005E   F0           MOVX      @DPTR,A
    113          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    114            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    115          #else
    116            uartConfig.callBackFunc         = NULL;
    117          #endif
    118          
    119            /* Start UART */
    120          #if defined (MT_UART_DEFAULT_PORT)
    121            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   00005F                ; Setup parameters for call to function HalUARTOpen
   \   00005F   AA..         MOV       R2,?XSP + 0
   \   000061   AB..         MOV       R3,?XSP + 1
   \   000063   7900         MOV       R1,#0x0
   \   000065   12....       LCALL     `??HalUARTOpen::?relay`; Banked call to: HalUARTOpen
    122          #else
    123            /* Silence IAR compiler warning */
    124            (void)uartConfig;
    125          #endif
    126          
    127            /* Initialize for ZApp */
    128          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    129            /* Default max bytes that ZAPP can take */
    130            MT_UartMaxZAppBufLen  = 1;
    131            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    132          #endif
    133          
    134          }
   \   000068   741D         MOV       A,#0x1d
   \   00006A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006D                REQUIRE ?Subroutine0
   \   00006D                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    135          
    136          /***************************************************************************************************
    137           * @fn      MT_SerialRegisterTaskID
    138           *
    139           * @brief   This function registers the taskID of the application so it knows
    140           *          where to send the messages whent they come in.
    141           *
    142           * @param   void
    143           *
    144           * @return  void
    145           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    146          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    147          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    148            App_TaskID = taskID;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   F0           MOVX      @DPTR,A
    149          }
   \   000009   80..         SJMP      ?Subroutine0
    150          
    151          /***************************************************************************************************
    152           * @fn      SPIMgr_CalcFCS
    153           *
    154           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    155           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    156           *
    157           * @param   byte *msg_ptr - message pointer
    158           * @param   byte len - length (in bytes) of message
    159           *
    160           * @return  result byte
    161           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    162          byte MT_UartCalcFCS(uint8 lastResult, uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    163          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    164            uint8 x;
    165            uint8 xorResult = lastResult;
    166          
    167            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000005   7800         MOV       R0,#0x0
   \   000007   800E         SJMP      ??MT_UartCalcFCS_0
    168              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   C9           XCH       A,R1
   \   00000F   69           XRL       A,R1
   \   000010   F9           MOV       R1,A
   \   000011   08           INC       R0
   \   000012   A3           INC       DPTR
   \   000013   AA82         MOV       R2,DPL
   \   000015   AB83         MOV       R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   000017   E8           MOV       A,R0
   \   000018   C3           CLR       C
   \   000019   9C           SUBB      A,R4
   \   00001A   40ED         JC        ??MT_UartCalcFCS_1
    169          
    170            return ( xorResult );
   \   00001C   7F01         MOV       R7,#0x1
   \   00001E   02....       LJMP      ?BANKED_LEAVE_XDATA
    171          }
    172          //自定义的串口接收回调函数

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    173          void MT_UartProcessZToolData1 ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData1:
    174          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 128
   \   000005   7480         MOV       A,#-0x80
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    175          
    176            uint8 flag = 0,i,j = 0;  //flag判断有没有数据，j记录数据长度
   \   00000C   75..00       MOV       ?V0,#0x0
   \   00000F   7F00         MOV       R7,#0x0
    177            uint8 buf[128];         //缓冲128
    178            (void)event;
   \   000011   801D         SJMP      ??MT_UartProcessZToolData1_0
    179          
    180            while(Hal_UART_RxBufLen(port)) //检测串口数据是否完成
    181            {
    182              HalUARTRead(port,&buf[j],1);//数据接收到buf
   \                     ??MT_UartProcessZToolData1_1:
   \   000013                ; Setup parameters for call to function HalUARTRead
   \   000013   7C01         MOV       R4,#0x1
   \   000015   7D00         MOV       R5,#0x0
   \   000017   EF           MOV       A,R7
   \   000018   F8           MOV       R0,A
   \   000019   85..82       MOV       DPL,?XSP + 0
   \   00001C   85..83       MOV       DPH,?XSP + 1
   \   00001F   E582         MOV       A,DPL
   \   000021   28           ADD       A,R0
   \   000022   FA           MOV       R2,A
   \   000023   E4           CLR       A
   \   000024   3583         ADDC      A,DPH
   \   000026   FB           MOV       R3,A
   \   000027   EE           MOV       A,R6
   \   000028   F9           MOV       R1,A
   \   000029   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
    183              j++;
   \   00002C   0F           INC       R7
    184              flag = 1;
   \   00002D   75..01       MOV       ?V0,#0x1
    185            }
   \                     ??MT_UartProcessZToolData1_0:
   \   000030                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000030   EE           MOV       A,R6
   \   000031   F9           MOV       R1,A
   \   000032   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   000035   EA           MOV       A,R2
   \   000036   4B           ORL       A,R3
   \   000037   70DA         JNZ       ??MT_UartProcessZToolData1_1
    186            if(flag == 1)   //有数据时
   \   000039   E5..         MOV       A,?V0
   \   00003B   6056         JZ        ??CrossCallReturnLabel_10
    187            {//分配内存，结构体+内容+长度
    188              pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof
    189                                                             ( mtOSALSerialData_t )+j+1);
   \   00003D                ; Setup parameters for call to function osal_msg_allocate
   \   00003D   EF           MOV       A,R7
   \   00003E   2405         ADD       A,#0x5
   \   000040   12....       LCALL     ?Subroutine4 & 0xFFFF
    190              pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??CrossCallReturnLabel_6:
   \   000043   12....       LCALL     ?Subroutine1 & 0xFFFF
    191              pMsg->msg = (uint8*)(pMsg+1); //把数据定位到结构体
    192              pMsg->msg [0]= j;             //记录数据长度
   \                     ??CrossCallReturnLabel_0:
   \   000046   EF           MOV       A,R7
   \   000047   8882         MOV       DPL,R0
   \   000049   8983         MOV       DPH,R1
   \   00004B   F0           MOVX      @DPTR,A
    193              for(i=0;i<j;i++)
   \   00004C   7A00         MOV       R2,#0x0
   \   00004E   8032         SJMP      ??MT_UartProcessZToolData1_2
    194                pMsg->msg [i+1]= buf[i];
   \                     ??MT_UartProcessZToolData1_3:
   \   000050   EA           MOV       A,R2
   \   000051   F8           MOV       R0,A
   \   000052   85..82       MOV       DPL,?XSP + 0
   \   000055   85..83       MOV       DPH,?XSP + 1
   \   000058   E582         MOV       A,DPL
   \   00005A   28           ADD       A,R0
   \   00005B   F582         MOV       DPL,A
   \   00005D   E4           CLR       A
   \   00005E   3583         ADDC      A,DPH
   \   000060   F583         MOV       DPH,A
   \   000062   E0           MOVX      A,@DPTR
   \   000063   C0E0         PUSH      A
   \   000065   90....       MOV       DPTR,#pMsg
   \   000068   E0           MOVX      A,@DPTR
   \   000069   FB           MOV       R3,A
   \   00006A   A3           INC       DPTR
   \   00006B   E0           MOVX      A,@DPTR
   \   00006C   F583         MOV       DPH,A
   \   00006E   8B82         MOV       DPL,R3
   \   000070   A3           INC       DPTR
   \   000071   A3           INC       DPTR
   \   000072   E0           MOVX      A,@DPTR
   \   000073   28           ADD       A,R0
   \   000074   FB           MOV       R3,A
   \   000075   A3           INC       DPTR
   \   000076   E0           MOVX      A,@DPTR
   \   000077   3400         ADDC      A,#0x0
   \   000079   8B82         MOV       DPL,R3
   \   00007B   F583         MOV       DPH,A
   \   00007D   A3           INC       DPTR
   \   00007E   D0E0         POP       A
   \   000080   F0           MOVX      @DPTR,A
   \   000081   0A           INC       R2
   \                     ??MT_UartProcessZToolData1_2:
   \   000082   EA           MOV       A,R2
   \   000083   C3           CLR       C
   \   000084   9F           SUBB      A,R7
   \   000085   40C9         JC        ??MT_UartProcessZToolData1_3
    195              osal_msg_send( App_TaskID, (byte *)pMsg ); // 登记任务并发往上层
   \   000087                ; Setup parameters for call to function osal_msg_send
   \   000087   90....       MOV       DPTR,#pMsg
   \   00008A   12....       LCALL     ?Subroutine3 & 0xFFFF
    196              osal_msg_deallocate ( (uint8 *)pMsg ); // 释放内存
   \                     ??CrossCallReturnLabel_4:
   \   00008D                ; Setup parameters for call to function osal_msg_deallocate
   \   00008D   90....       MOV       DPTR,#pMsg
   \   000090   12....       LCALL     ?Subroutine6 & 0xFFFF
    197            }
    198          }
   \                     ??CrossCallReturnLabel_10:
   \   000093   7480         MOV       A,#-0x80
   \   000095   12....       LCALL     ?DEALLOC_XSTACK8
   \   000098   7F04         MOV       R7,#0x4
   \   00009A   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   FA           MOV       R2,A
   \   000001   E4           CLR       A
   \   000002   3400         ADDC      A,#0x0
   \   000004   FB           MOV       R3,A
   \   000005   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000008   90....       MOV       DPTR,#pMsg
   \   00000B   EA           MOV       A,R2
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   A3           INC       DPTR
   \   00000E   EB           MOV       A,R3
   \   00000F   F0           MOVX      @DPTR,A
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   E0           MOVX      A,@DPTR
   \   000009   F9           MOV       R1,A
   \   00000A   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   F583         MOV       DPH,A
   \   000002   8A82         MOV       DPL,R2
   \   000004   7401         MOV       A,#0x1
   \   000006   F0           MOVX      @DPTR,A
   \   000007   90....       MOV       DPTR,#pMsg
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   2404         ADD       A,#0x4
   \   00000D   F8           MOV       R0,A
   \   00000E   A3           INC       DPTR
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   3400         ADDC      A,#0x0
   \   000012   F9           MOV       R1,A
   \   000013   90....       MOV       DPTR,#pMsg
   \   000016   E0           MOVX      A,@DPTR
   \   000017   FA           MOV       R2,A
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F583         MOV       DPH,A
   \   00001C   8A82         MOV       DPL,R2
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   E8           MOV       A,R0
   \   000021   F0           MOVX      @DPTR,A
   \   000022   A3           INC       DPTR
   \   000023   E9           MOV       A,R1
   \   000024   F0           MOVX      @DPTR,A
   \   000025   22           RET
    199          
    200          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    201          /***************************************************************************************************
    202           * @fn      MT_UartProcessZToolData
    203           *
    204           * @brief   | SOP | CMD |Data Length| cmdEP | Address | EndPoint |  Data  | FSC |
    205           *          |  1  |  2  |    1      |   2   |    2    |     1    | 1 ~119 |  1  |
    206           *
    207           *          Parses the data and determine either is SPI or just simply serial data
    208           *          then send the data to correct place (MT or APP)
    209           *
    210           * @param   port     - UART port
    211           *          event    - Event that causes the callback
    212           *
    213           *
    214           * @return  None
    215           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    216          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    217          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    218              uint8  ch;
    219              uint8  bytesInRxBuffer;
    220          
    221              (void)event;  // Intentionally unreferenced parameter
   \   00000C   802B         SJMP      ??MT_UartProcessZToolData_0
    222          
    223              while (Hal_UART_RxBufLen(port))
    224              {
    225                  HalUARTRead (port, &ch, 1);
    226          
    227                  switch(state)
    228                  {
    229                  case SOP_STATE:
    230                      if(ch == MT_UART_SOF)
    231                          state = LEN_STATE;
    232                      break;
    233                  case LEN_STATE:
    234                      if(ch < 7)
    235                      {
    236                          // invalid length field
    237                          state = SOP_STATE;
    238                          break;
    239                      }
    240                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) +
    241                                                                     ch + 3);//SOP+LEN+FSC
    242                      tempDataLen = 0;
    243                      /* Allocate memory for the data */
    244          //            pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) + sizeof(mtUserSerialMsg_t) +
    245          //                                                           ch - 5);
    246                      if (pMsg)
    247                      {
    248                          /* Fill up what we can */
    249                          pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   12....       LCALL     ?Subroutine1 & 0xFFFF
    250                          pMsg->msg = (uint8*)(pMsg + 1);
    251                          pMsgContent = (mtUserSerialMsg_t *)pMsg->msg;
   \                     ??CrossCallReturnLabel_1:
   \   000012   90....       MOV       DPTR,#pMsgContent
   \   000015   E8           MOV       A,R0
   \   000016   F0           MOVX      @DPTR,A
   \   000017   A3           INC       DPTR
   \   000018   E9           MOV       A,R1
   \   000019   F0           MOVX      @DPTR,A
    252                          pMsgContent->sop = MT_UART_SOF;
   \   00001A   F583         MOV       DPH,A
   \   00001C   8882         MOV       DPL,R0
   \   00001E   A3           INC       DPTR
   \   00001F   7402         MOV       A,#0x2
   \   000021   F0           MOVX      @DPTR,A
    253                          pMsgContent->len = ch;
   \   000022   85..82       MOV       DPL,?XSP + 0
   \   000025   85..83       MOV       DPH,?XSP + 1
   \   000028   E0           MOVX      A,@DPTR
   \   000029   C0E0         PUSH      A
   \   00002B   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   00002E   A3           INC       DPTR
   \   00002F   A3           INC       DPTR
   \   000030   D0E0         POP       A
   \   000032   F0           MOVX      @DPTR,A
    254                          state = DATA_STATE;
   \   000033   90....       MOV       DPTR,#state
   \   000036   7402         MOV       A,#0x2
   \                     ??MT_UartProcessZToolData_2:
   \   000038   F0           MOVX      @DPTR,A
    255                      }
    256                      else
    257                      {
    258                          pMsgContent = NULL;
    259                          state = SOP_STATE;
    260                          return;
    261                      }
    262                      break;
   \                     ??MT_UartProcessZToolData_0:
   \   000039                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000039   EE           MOV       A,R6
   \   00003A   F9           MOV       R1,A
   \   00003B   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   00003E   EA           MOV       A,R2
   \   00003F   4B           ORL       A,R3
   \   000040   7003         JNZ       $+5
   \   000042   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
   \   000045                ; Setup parameters for call to function HalUARTRead
   \   000045   7C01         MOV       R4,#0x1
   \   000047   7D00         MOV       R5,#0x0
   \   000049   AA..         MOV       R2,?XSP + 0
   \   00004B   AB..         MOV       R3,?XSP + 1
   \   00004D   EE           MOV       A,R6
   \   00004E   F9           MOV       R1,A
   \   00004F   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000052   90....       MOV       DPTR,#state
   \   000055   E0           MOVX      A,@DPTR
   \   000056   600E         JZ        ??MT_UartProcessZToolData_4
   \   000058   14           DEC       A
   \   000059   601D         JZ        ??MT_UartProcessZToolData_5
   \   00005B   14           DEC       A
   \   00005C   604E         JZ        ??MT_UartProcessZToolData_6
   \   00005E   14           DEC       A
   \   00005F   7003         JNZ       $+5
   \   000061   02....       LJMP      ??MT_UartProcessZToolData_7 & 0xFFFF
   \   000064   80D3         SJMP      ??MT_UartProcessZToolData_0
   \                     ??MT_UartProcessZToolData_4:
   \   000066   85..82       MOV       DPL,?XSP + 0
   \   000069   85..83       MOV       DPH,?XSP + 1
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   6402         XRL       A,#0x2
   \   00006F   70C8         JNZ       ??MT_UartProcessZToolData_0
   \   000071   90....       MOV       DPTR,#state
   \   000074   7401         MOV       A,#0x1
   \   000076   80C0         SJMP      ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_5:
   \   000078   85..82       MOV       DPL,?XSP + 0
   \   00007B   85..83       MOV       DPH,?XSP + 1
   \   00007E   E0           MOVX      A,@DPTR
   \   00007F   C3           CLR       C
   \   000080   9407         SUBB      A,#0x7
   \   000082   5003         JNC       $+5
   \   000084   02....       LJMP      ??CrossCallReturnLabel_11 & 0xFFFF
   \   000087                ; Setup parameters for call to function osal_msg_allocate
   \   000087   E0           MOVX      A,@DPTR
   \   000088   2407         ADD       A,#0x7
   \   00008A   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   00008D   90....       MOV       DPTR,#tempDataLen
   \   000090   E4           CLR       A
   \   000091   F0           MOVX      @DPTR,A
   \   000092   90....       MOV       DPTR,#pMsg + 1
   \   000095   E0           MOVX      A,@DPTR
   \   000096   F9           MOV       R1,A
   \   000097   EA           MOV       A,R2
   \   000098   49           ORL       A,R1
   \   000099   6003         JZ        $+5
   \   00009B   02....       LJMP      ??MT_UartProcessZToolData_1 & 0xFFFF
   \   00009E   90....       MOV       DPTR,#pMsgContent
   \   0000A1   E4           CLR       A
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   A3           INC       DPTR
   \   0000A4   F0           MOVX      @DPTR,A
   \   0000A5   90....       MOV       DPTR,#state
   \   0000A8   F0           MOVX      @DPTR,A
   \   0000A9   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
    263                  case DATA_STATE:
    264                      pMsgContent->dataBody[tempDataLen++] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000AC   85..82       MOV       DPL,?XSP + 0
   \   0000AF   85..83       MOV       DPH,?XSP + 1
   \   0000B2   E0           MOVX      A,@DPTR
   \   0000B3   C0E0         PUSH      A
   \   0000B5   90....       MOV       DPTR,#tempDataLen
   \   0000B8   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   0000BB   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   0000BE   D0E0         POP       A
   \   0000C0   F0           MOVX      @DPTR,A
   \   0000C1   90....       MOV       DPTR,#tempDataLen
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   04           INC       A
   \   0000C6   F0           MOVX      @DPTR,A
    265                      /* Check number of bytes left in the Rx buffer */
    266                      bytesInRxBuffer = Hal_UART_RxBufLen(port);
   \   0000C7                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   0000C7   EE           MOV       A,R6
   \   0000C8   F9           MOV       R1,A
   \   0000C9   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   0000CC   EA           MOV       A,R2
   \   0000CD   FF           MOV       R7,A
    267          
    268                      /* If the remain of the data is there, read them all, otherwise, just read enough */
    269                      if (bytesInRxBuffer <= pMsgContent->len - tempDataLen)
   \   0000CE   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000D1   F8           MOV       R0,A
   \   0000D2   90....       MOV       DPTR,#tempDataLen
   \   0000D5   E0           MOVX      A,@DPTR
   \   0000D6   FA           MOV       R2,A
   \   0000D7   E8           MOV       A,R0
   \   0000D8   C3           CLR       C
   \   0000D9   9A           SUBB      A,R2
   \   0000DA   F8           MOV       R0,A
   \   0000DB   95E0         SUBB      A,0xE0 /* A   */
   \   0000DD   F9           MOV       R1,A
   \   0000DE   EF           MOV       A,R7
   \   0000DF   FA           MOV       R2,A
   \   0000E0   C3           CLR       C
   \   0000E1   E8           MOV       A,R0
   \   0000E2   9A           SUBB      A,R2
   \   0000E3   E9           MOV       A,R1
   \   0000E4   9400         SUBB      A,#0x0
   \   0000E6   A2D2         MOV       C,0xD0 /* PSW */.2
   \   0000E8   65D0         XRL       A,PSW
   \   0000EA   33           RLC       A
   \   0000EB   4010         JC        ??MT_UartProcessZToolData_8
    270                      {
    271                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], bytesInRxBuffer);
   \   0000ED                ; Setup parameters for call to function HalUARTRead
   \   0000ED   EF           MOV       A,R7
   \   0000EE   FC           MOV       R4,A
   \   0000EF   7D00         MOV       R5,#0x0
   \   0000F1   E0           MOVX      A,@DPTR
   \   0000F2   F8           MOV       R0,A
   \   0000F3   12....       LCALL     ?Subroutine2 & 0xFFFF
    272                          tempDataLen += bytesInRxBuffer;
   \                     ??CrossCallReturnLabel_2:
   \   0000F6   90....       MOV       DPTR,#tempDataLen
   \   0000F9   E0           MOVX      A,@DPTR
   \   0000FA   2F           ADD       A,R7
   \   0000FB   801C         SJMP      ??MT_UartProcessZToolData_9
    273                      }
    274                      else
    275                      {
    276                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], pMsgContent->len - tempDataLen);
   \                     ??MT_UartProcessZToolData_8:
   \   0000FD   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000100   FA           MOV       R2,A
   \   000101   A3           INC       DPTR
   \   000102   E0           MOVX      A,@DPTR
   \   000103   F583         MOV       DPH,A
   \   000105   8A82         MOV       DPL,R2
   \   000107   A3           INC       DPTR
   \   000108   A3           INC       DPTR
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   C3           CLR       C
   \   00010B   98           SUBB      A,R0
   \   00010C   FC           MOV       R4,A
   \   00010D   95E0         SUBB      A,0xE0 /* A   */
   \   00010F   FD           MOV       R5,A
   \   000110   12....       LCALL     ?Subroutine2 & 0xFFFF
    277                          tempDataLen += (pMsgContent->len - tempDataLen);
   \                     ??CrossCallReturnLabel_3:
   \   000113   12....       LCALL     ?Subroutine5 & 0xFFFF
    278                      }
   \                     ??CrossCallReturnLabel_9:
   \   000116   90....       MOV       DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_9:
   \   000119   F0           MOVX      @DPTR,A
    279                      /* If number of bytes read is equal to data length, time to move on to FCS */
    280                      if ( tempDataLen == pMsgContent->len )
   \   00011A   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00011D   F9           MOV       R1,A
   \   00011E   A3           INC       DPTR
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   F583         MOV       DPH,A
   \   000122   8982         MOV       DPL,R1
   \   000124   A3           INC       DPTR
   \   000125   A3           INC       DPTR
   \   000126   E0           MOVX      A,@DPTR
   \   000127   68           XRL       A,R0
   \   000128   6003         JZ        $+5
   \   00012A   02....       LJMP      ??MT_UartProcessZToolData_0 & 0xFFFF
    281                          state = FCS_STATE;
   \   00012D   90....       MOV       DPTR,#state
   \   000130   7403         MOV       A,#0x3
   \   000132   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    282                      break;
    283                  case FCS_STATE:
    284                      /* Make sure it's correct */
    285                      {
    286                          pMsgContent->fsc = ch;
   \                     ??MT_UartProcessZToolData_7:
   \   000135   85..82       MOV       DPL,?XSP + 0
   \   000138   85..83       MOV       DPH,?XSP + 1
   \   00013B   E0           MOVX      A,@DPTR
   \   00013C   C0E0         PUSH      A
   \   00013E   12....       LCALL     ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000141   D0E0         POP       A
   \   000143   F0           MOVX      @DPTR,A
    287                          uint8 fcs = MT_UartCalcFCS(0, &pMsgContent->len, 1);
   \   000144   90....       MOV       DPTR,#pMsgContent
   \   000147   E0           MOVX      A,@DPTR
   \   000148   2402         ADD       A,#0x2
   \   00014A   F5..         MOV       ?V0,A
   \   00014C   A3           INC       DPTR
   \   00014D   E0           MOVX      A,@DPTR
   \   00014E   3400         ADDC      A,#0x0
   \   000150   F5..         MOV       ?V1,A
   \   000152                ; Setup parameters for call to function MT_UartCalcFCS
   \   000152   7C01         MOV       R4,#0x1
   \   000154   AA..         MOV       R2,?V0
   \   000156   FB           MOV       R3,A
   \   000157   7900         MOV       R1,#0x0
   \   000159   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   00015C   E9           MOV       A,R1
   \   00015D   F9           MOV       R1,A
    288                          fcs = MT_UartCalcFCS(fcs, pMsgContent->dataBody, pMsgContent->len);
   \   00015E                ; Setup parameters for call to function MT_UartCalcFCS
   \   00015E   85..82       MOV       DPL,?V0
   \   000161   85..83       MOV       DPH,?V1
   \   000164   E0           MOVX      A,@DPTR
   \   000165   FC           MOV       R4,A
   \   000166   90....       MOV       DPTR,#pMsgContent
   \   000169   E0           MOVX      A,@DPTR
   \   00016A   2403         ADD       A,#0x3
   \   00016C   FA           MOV       R2,A
   \   00016D   A3           INC       DPTR
   \   00016E   E0           MOVX      A,@DPTR
   \   00016F   3400         ADDC      A,#0x0
   \   000171   FB           MOV       R3,A
   \   000172   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   000175   E9           MOV       A,R1
   \   000176   F9           MOV       R1,A
    289                          if(fcs == ch)
   \   000177   85..82       MOV       DPL,?XSP + 0
   \   00017A   85..83       MOV       DPH,?XSP + 1
   \   00017D   E0           MOVX      A,@DPTR
   \   00017E   69           XRL       A,R1
   \   00017F   90....       MOV       DPTR,#pMsg
   \   000182   7005         JNZ       ??MT_UartProcessZToolData_10
    290                              osal_msg_send(App_TaskID, (byte *)pMsg);
   \   000184                ; Setup parameters for call to function osal_msg_send
   \   000184   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000187   8003         SJMP      ??CrossCallReturnLabel_11
    291                          else
    292                              osal_msg_deallocate((uint8 *)pMsg);
   \                     ??MT_UartProcessZToolData_10:
   \   000189                ; Setup parameters for call to function osal_msg_deallocate
   \   000189   12....       LCALL     ?Subroutine6 & 0xFFFF
    293                      }
    294                      /* Reset the state, send or discard the buffers at this point */
    295                      state = SOP_STATE;
   \                     ??CrossCallReturnLabel_11:
   \   00018C   90....       MOV       DPTR,#state
   \   00018F   E4           CLR       A
   \   000190   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    296                      break;
    297                  default:
    298                      break;
    299                  }
    300              }
    301          }
   \                     ??MT_UartProcessZToolData_3:
   \   000193   7401         MOV       A,#0x1
   \   000195   12....       LCALL     ?DEALLOC_XSTACK8
   \   000198   7F02         MOV       R7,#0x2
   \   00019A   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F583         MOV       DPH,A
   \   000009   8882         MOV       DPL,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002                ; Setup parameters for call to function HalUARTRead
   \   000002   90....       MOV       DPTR,#pMsgContent
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL     ?Subroutine10 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000007   AA82         MOV       R2,DPL
   \   000009   AB83         MOV       R3,DPH
   \   00000B   EE           MOV       A,R6
   \   00000C   F9           MOV       R1,A
   \   00000D   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   28           ADD       A,R0
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   3400         ADDC      A,#0x0
   \   000006   8A82         MOV       DPL,R2
   \   000008   F583         MOV       DPH,A
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartRegisterTaskID::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartRegisterTaskID

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartCalcFCS::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartCalcFCS

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartProcessZToolData1::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData1

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MT_UartProcessZToolData::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MT_UartProcessZToolData
    302          #if 0
    303          void MT_UartProcessAppData ( uint8 port, uint8 event )
    304          {
    305             uint8  *bytesInRxBuffer;
    306            static uint8 *msg;
    307          
    308            (void)event;  // Intentionally unreferenced parameter
    309            msg = (uint8 *)osal_msg_allocate(5);
    310            if(msg){
    311              bytesInRxBuffer = msg;
    312              *bytesInRxBuffer ++ = CMD_SERIAL_MSG;
    313            }
    314            while (Hal_UART_RxBufLen(port))
    315            {
    316              HalUARTRead (port, bytesInRxBuffer , 5);
    317              osal_msg_send( App_TaskID, (byte *)msg );
    318            }
    319          
    320          }
    321          #endif
    322          
    323          #endif
    324          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    325          /***************************************************************************************************
    326           * @fn      MT_UartProcessZAppData
    327           *
    328           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    329           *          |  1  |  2   |       1         |  1   |
    330           *
    331           *          Parses the data and determine either is SPI or just simply serial data
    332           *          then send the data to correct place (MT or APP)
    333           *
    334           * @param   port    - UART port
    335           *          event   - Event that causes the callback
    336           *
    337           *
    338           * @return  None
    339           ***************************************************************************************************/
    340          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    341          {
    342          
    343            osal_event_hdr_t  *msg_ptr;
    344            uint16 length = 0;
    345            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    346          
    347            /*
    348               If maxZAppBufferLength is 0 or larger than current length
    349               the entire length of the current buffer is returned.
    350            */
    351            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    352            {
    353              length = MT_UartMaxZAppBufLen;
    354            }
    355            else
    356            {
    357              length = rxBufLen;
    358            }
    359          
    360            /* Verify events */
    361            if (event == HAL_UART_TX_FULL)
    362            {
    363              // Do something when TX if full
    364              return;
    365            }
    366          
    367            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    368            {
    369              if ( App_TaskID )
    370              {
    371                /*
    372                   If Application is ready to receive and there is something
    373                   in the Rx buffer then send it up
    374                */
    375                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    376                {
    377                  /* Disable App flow control until it processes the current data */
    378                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    379          
    380                  /* 2 more bytes are added, 1 for CMD type, other for length */
    381                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    382                  if ( msg_ptr )
    383                  {
    384                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    385                    msg_ptr->status = length;
    386          
    387                    /* Read the data of Rx buffer */
    388                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    389          
    390                    /* Send the raw data to application...or where ever */
    391                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    392                  }
    393                }
    394              }
    395            }
    396          }
    397          
    398          /***************************************************************************************************
    399           * @fn      SPIMgr_ZAppBufferLengthRegister
    400           *
    401           * @brief
    402           *
    403           * @param   maxLen - Max Length that the application wants at a time
    404           *
    405           * @return  None
    406           *
    407           ***************************************************************************************************/
    408          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    409          {
    410            /* If the maxLen is larger than the RX buff, something is not right */
    411            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    412              MT_UartMaxZAppBufLen = maxLen;
    413            else
    414              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    415          }
    416          
    417          /***************************************************************************************************
    418           * @fn      SPIMgr_AppFlowControl
    419           *
    420           * @brief
    421           *
    422           * @param   status - ready to send or not
    423           *
    424           * @return  None
    425           *
    426           ***************************************************************************************************/
    427          void MT_UartAppFlowControl ( bool status )
    428          {
    429          
    430            /* Make sure only update if needed */
    431            if (status != MT_UartZAppRxStatus )
    432            {
    433              MT_UartZAppRxStatus = status;
    434            }
    435          
    436            /* App is ready to read again, ProcessZAppData have to be triggered too */
    437            if (status == MT_UART_ZAPP_RX_READY)
    438            {
    439              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    440            }
    441          
    442          }
    443          
    444          #endif //ZAPP
    445          
    446          /***************************************************************************************************
    447          ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     20   MT_UartCalcFCS
      2     29   MT_UartInit
        2     29   -> HalUARTOpen
      1     11   MT_UartProcessZToolData
        0     11   -> HalUARTRead
        0     11   -> Hal_UART_RxBufLen
        0     11   -> MT_UartCalcFCS
        0     11   -> osal_msg_allocate
        0     11   -> osal_msg_deallocate
        0     11   -> osal_msg_send
      1    140   MT_UartProcessZToolData1
        0    140   -> HalUARTRead
        0    140   -> Hal_UART_RxBufLen
        0    140   -> osal_msg_allocate
        0    140   -> osal_msg_deallocate
        0    140   -> osal_msg_send
      2      0   MT_UartRegisterTaskID


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?Subroutine0
      38  ?Subroutine1
      12  ?Subroutine10
      17  ?Subroutine2
      14  ?Subroutine3
      17  ?Subroutine4
       7  ?Subroutine5
       9  ?Subroutine6
       7  ?Subroutine7
       4  ?Subroutine8
      14  ?Subroutine9
       1  App_TaskID
      33  MT_UartCalcFCS
       6  MT_UartCalcFCS::?relay
     109  MT_UartInit
       6  MT_UartInit::?relay
     413  MT_UartProcessZToolData
     157  MT_UartProcessZToolData1
       6  MT_UartProcessZToolData1::?relay
       6  MT_UartProcessZToolData::?relay
      11  MT_UartRegisterTaskID
       6  MT_UartRegisterTaskID::?relay
       2  pMsg
       2  pMsgContent
       1  state
       1  tempDataLen

 
 869 bytes in segment BANKED_CODE
  30 bytes in segment BANK_RELAYS
   7 bytes in segment XDATA_Z
 
  30 bytes of CODE     memory
 869 bytes of HUGECODE memory
   7 bytes of XDATA    memory

Errors: none
Warnings: none
